// Movutl autogenerated file (PropsWriter)
#include <movutl/core/props.hpp>
#include <movutl/app/app.hpp>
#include <movutl/asset/entity.hpp>
#include <movutl/asset/text.hpp>
#include <movutl/asset/image.hpp>
#include <movutl/asset/movie.hpp>
#include <movutl/core/anim.hpp>
#include <movutl/asset/track.hpp>
#include <movutl/asset/composition.hpp>
namespace mu { 
void Movie::setProps(const Props& p) {
   if(p.has<Vec3>("pos")) pos = p.get<Vec3>("pos");
  if(p.has<Vec2>("scale")) scale = p.get<Vec2>("scale");
  if(p.has<float>("rotation")) rotation = p.get<float>("rotation");
  if(p.has<int>("start_frame_")) start_frame_ = p.get<int>("start_frame_");
  if(p.has<float>("speed")) speed = p.get<float>("speed");
  if(p.has<int>("alpha_")) alpha_ = p.get<int>("alpha_");
  if(p.has<bool>("loop_")) loop_ = p.get<bool>("loop_");
  if(p.has<bool>("with_alpha_")) with_alpha_ = p.get<bool>("with_alpha_");
  if(p.has<std::string>("path_")) path_ = p.get<std::string>("path_");
}
PropsInfo Movie::getPropsInfo() const {
  PropsInfo info;
  info.add_vec3_prop("pos", "", "", Vec3 ( 0 , 0 , 0 ), 0, 0, 1);
  info.set_last_prop_dispname("位置");
  info.add_vec2_prop("scale", "", "", Vec2 ( 100 , 100 ), 0, 0, 1);
  info.set_last_prop_dispname("拡大率");
  info.add_float_prop("rotation", "", "", 0,  0, 0, 1, false, false);
  info.set_last_prop_dispname("回転");
  info.add_int_prop("start_frame_", "", "", 0,  0, 0, 0);
  info.set_last_prop_dispname("開始フレーム");
  info.add_float_prop("speed", "", "", 100.0,  0.0, 10000.0, 5.0, false, false);
  info.set_last_prop_dispname("再生速度");
  info.add_int_prop("alpha_", "", "", 255,  0, 0, 0);
  info.set_last_prop_dispname("透明度");
  info.add_bool_prop("loop_", "", "", false);
  info.set_last_prop_dispname("ループ再生");
  info.add_bool_prop("with_alpha_", "", "", false);
  info.set_last_prop_dispname("透明度を読み込む");
  info.add_string_prop("path_", "", "", """");
  info.set_last_prop_dispname("ファイル");
  return info;
}
Props Movie::getProps() const {
   Props p;
  p["pos"] = pos;
  p["scale"] = scale;
  p["rotation"] = rotation;
  p["start_frame_"] = start_frame_;
  p["speed"] = speed;
  p["alpha_"] = alpha_;
  p["loop_"] = loop_;
  p["with_alpha_"] = with_alpha_;
  p["path_"] = path_;
  return p;
}
void TextEntt::setProps(const Props& p) {
   if(p.has<Vec3>("pos_")) pos_ = p.get<Vec3>("pos_");
  if(p.has<float>("scale_x_")) scale_x_ = p.get<float>("scale_x_");
  if(p.has<float>("scale_y_")) scale_y_ = p.get<float>("scale_y_");
  if(p.has<float>("rot_")) rot_ = p.get<float>("rot_");
  if(p.has<float>("speed")) speed = p.get<float>("speed");
  if(p.has<int>("alpha_")) alpha_ = p.get<int>("alpha_");
  if(p.has<std::string>("font")) font = p.get<std::string>("font");
  if(p.has<std::string>("text")) text = p.get<std::string>("text");
  if(p.has<bool>("separate")) separate = p.get<bool>("separate");
}
PropsInfo TextEntt::getPropsInfo() const {
  PropsInfo info;
  info.add_vec3_prop("pos_", "", "", Vec3(0, 0, 0), 0, 0, 1);
  info.set_last_prop_dispname("位置 viewer_anchor");
  info.add_float_prop("scale_x_", "", "", 1.0,  0, 0, 1, false, false);
  info.set_last_prop_dispname("拡大率X");
  info.add_float_prop("scale_y_", "", "", 1.0,  0, 0, 1, false, false);
  info.set_last_prop_dispname("拡大率Y");
  info.add_float_prop("rot_", "", "", 0.0,  0, 0, 1, false, false);
  info.set_last_prop_dispname("回転");
  info.add_float_prop("speed", "", "", 100.0,  0, 0, 1, false, false);
  info.set_last_prop_dispname("再生速度");
  info.add_int_prop("alpha_", "", "", 255,  0, 0, 0);
  info.set_last_prop_dispname("透明度");
  info.add_string_prop("font", "", "", """");
  info.set_last_prop_dispname("フォント");
  info.add_string_prop("text", "", "", """");
  info.set_last_prop_dispname("テキスト");
  info.add_bool_prop("separate", "", "", false);
  info.set_last_prop_dispname("個別オブジェクト");
  return info;
}
Props TextEntt::getProps() const {
   Props p;
  p["pos_"] = pos_;
  p["scale_x_"] = scale_x_;
  p["scale_y_"] = scale_y_;
  p["rot_"] = rot_;
  p["speed"] = speed;
  p["alpha_"] = alpha_;
  p["font"] = font;
  p["text"] = text;
  p["separate"] = separate;
  return p;
}
} // namespace mu
