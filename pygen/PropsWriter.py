from pygen_types import MFunction, MEnum, MClass, MArgument, ArgumentType
from typing import List


class PropsWriter:
    PREFIX = "props_"
    STUB_COMMENT = "// Movutl autogenerated file (PropsWriter)\n"

    def set(
        self,
        funcs_list: List[MFunction],
        enums_list: List[MEnum],
        classes_list: List[MClass],
    ):
        for c in classes_list:
            self.register_class(c)

    def __init__(self, filename: str):
        self.autogen_text = (
            "#include <sol.hpp>\n"
            "#include <sol/sol.hpp>\n"
            "#include <sol/forward.hpp>\n"
            "#include <lua.hpp>\n"
            "namespace mu { \n"
            f"void generated_props_parser_{self.PREFIX}(){{\n"
            "  sol::state_view lua;\n"
        )

        self.output_filename = "../../runtime/melchior/" + filename

    def save(self):
        self.autogen_text += "# ---- end of file ----"

        with open(self.output_filename, "w") as f:
            f.write(self.STUB_COMMENT)
            f.write(self.autogen_text)

    def _should_write(self, cls: MClass, funcname: str):
        for f in cls.funcs:
            if f.name == funcname:
                return f.should_autogen
        return False

    def register_class(self, cls: MClass):
        if self._should_write(cls, "setProps"):
            self._write_setProps(cls)
        if self._should_write(cls, "getPropsInfo"):
            self._write_getPropsInfo_fn(cls)
        if self._should_write(cls, "getPropsInfo"):
            self._write_getPropsInfo_fn(cls)

    def _write_setProps(self, cls: MClass):
        self.autogen_text += f"void {cls.name}::setProps(const Props& p) {{\n "  #

        for p in cls.props:
            match p.ptype_:
                case ArgumentType.ArgType_Float:
                    self.autogen_text += f'  if(p.has<float>("{p.name}")) {p.name} = p.get<float>("{p.name}");\n'
                case ArgumentType.ArgType_Int:
                    self.autogen_text += f'  if(p.has<int>("{p.name}")) {p.name} = p.get<int>("{p.name}");\n'
                case ArgumentType.ArgType_Bool:
                    self.autogen_text += f'  if(p.has<bool>("{p.name}")) {p.name} = p.get<bool>("{p.name}");\n'
                case ArgumentType.ArgType_String:
                    self.autogen_text += f'  if(p.has<std::string>("{p.name}")) {p.name} = p.get<std::string>("{p.name}");\n'
                case ArgumentType.ArgType_Path:
                    self.autogen_text += f'  if(p.has<std::string>("{p.name}")) {p.name} = p.get<std::string>("{p.name}");\n'
                case ArgumentType.ArgType_Color:
                    self.autogen_text += f'  if(p.has<Vec4b>("{p.name}")) {p.name} = p.get<Vec4b>("{p.name}");\n'
                case ArgumentType.ArgType_Vec3:
                    self.autogen_text += f'  if(p.has<Vec3f>("{p.name}")) {p.name} = p.get<Vec3f>("{p.name}");\n'
                case ArgumentType.ArgType_Selection:
                    self.autogen_text += f'  if(p.has<int>("{p.name}")) {p.name} = p.get<int>("{p.name}");\n'
                case _:
                    self.autogen_text += f"// {p.name} has an unsupported type\n"
        self.autogen_text += "}\n"

    def _write_getPropsInfo_fn(self, cls: MClass):
        self.autogen_text += (
            f"PropsInfo {cls.name}::getPropsInfo() const {{\n "  #
            + " PropsInfo info;\n"
        )

        for p in cls.props:
            match p.ptype_:
                case ArgumentType.ArgType_Float:
                    self.autogen_text += (
                        f'  info.add_float_prop("{p.name}", "{p.category}", "{p.desc}", {p.detault_value}, '
                        + "     0, 0, 0, {p.is_angle}, false);\n"
                    )
                case ArgumentType.ArgType_Int:
                    self.autogen_text += (
                        f'  info.add_int_prop("{p.name}", "{p.category}", "{p.desc}", {p.detault_value}, '
                        + "     0, 0, 0);\n"
                    )
                case ArgumentType.ArgType_Bool:
                    self.autogen_text += f'  info.add_bool_prop("{p.name}", "{p.category}", "{p.desc}", {p.detault_value});\n'
                case ArgumentType.ArgType_String:
                    self.autogen_text += f'  info.add_string_prop("{p.name}", "{p.category}", "{p.desc}", "{p.detault_value}");\n'
                case ArgumentType.ArgType_Path:
                    self.autogen_text += f'  info.add_path_prop("{p.name}", "{p.category}", "{p.desc}", "{p.detault_value}");\n'
                case ArgumentType.ArgType_Color:
                    self.autogen_text += f'  info.add_color_prop("{p.name}", "{p.category}", "{p.desc}", {p.detault_value});\n'
                case ArgumentType.ArgType_Vec3:
                    self.autogen_text += (
                        f'  info.add_vec3_prop("{p.name}", "{p.category}", "{p.desc}", {p.detault_value}, '
                        + "     0, 0, 0);\n"
                    )
                case ArgumentType.ArgType_Selection:
                    self.autogen_text += f'  info.add_selection_prop("{p.name}", "{p.category}", "{p.desc}", {p.detault_value});\n'
                case _:
                    self.autogen_text += f"// {p.name} has an unsupported type\n"
        self.autogen_text += "  return props;\n}\n"
